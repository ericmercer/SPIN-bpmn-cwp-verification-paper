The model of the workflow and CWP object state require behaviors defined for all input. For example, the CWP object state is transformed over time by various distributed activities carried out by different actors. Some aspects of the object state are transformed directly by the system workflow while others are inputs on which a workflow makes decisions. These later inputs form the \emph{environment} in which the CWP exists. For verification, the behavior of these environment inputs must be modeled, and the verification results only hold relative to the behaviors considered by that environment model. The same is true for aspects of the workflow. Each is discussed below.

\subsection{CWP Environment Model}
In this model, all the data in the CWP object state are part of the environment, and as such, are inputs on which any workflow makes decisions. For example, the severity of the patient is established by an exam with a physician, but that severity is fundamentally a characteristic of the patient and the progression of the disease. The physician assesses the patient and ascribes a severity, but the patient, with their symptoms, are an input to the model. The same with the care capability level and the trending severity. These are values on which a workflow makes decisions regarding patient risk and appropriate intervention. 

There is, of course, a causal relationship between the decisions in a workflow and the resulting subsequent input. For example, it is normally expected that when a doctor orders a patient admitted to the hospital that at some point in the future the severity rating for the patient diminishes due to the increased level of intervention and care. Here is where modeling choices can limit the impact, and meaning, of any verification results as the verification only hold for the modeled input behavior.

This model of the CWP for remote patient care creates the weakest, that is to say, the least restrictive, environment model possible in which a workflow is able to be verified. That means the environment model includes behavior that exists in the real world (i.e., the causal relationships), and it includes behaviors that do not exist in the real world. The goal is to create a \emph{sound over-approximation} of feasible environment behavior meaning that it includes the real world behavior plus other behavior that is not possible in the real world. If a workflow verifies in the sound over-approximated environment, then by implication, that verification result holds in the real world since those behaviors are a subset of those considered for verification. 

The verification model assumes the \texttt{orders} from an examining physician correlate strongly with \texttt{severity}. A \texttt{severity} level below two does not require hospitalization according to the DRG scale while anything above two is the opposite.
%
{\small
\begin{lstlisting}[style=myPromela]
inline updateDoctorOrders(severity, orders) {
if
:: isRequiresHospital(severity) ->
  setHospital(orders)
:: else ->
  if
    :: (severity != 0) -> 
      setHomeCare(orders)
    :: else -> 
      setDischarge(orders)
  fi
fi
logOrders(orders)
}
\end{lstlisting}
}
%
\noindent The orders are deterministic based on the value of \texttt{severity}. The patient is always admitted to the hospital when \texttt{severity} is two or greater; otherwise, the patient is either discharged or prescribed continued care at home. In this model, a patient is only discharged if \texttt{severity} is 0 at the time of exam.

The model for the \texttt{severity} strongly correlates with \texttt{trendSeverity}.
%
{\small
\begin{lstlisting}[style=myPromela]
inline updatePatientSeverity(trendSeverity, 
  severity) {
  if
  :: isWithinCareCapability(trendSeverity) -> 
      if
      :: true -> setSeverity(severity, 0)
      :: true -> setSeverity(severity, 1)
      fi
  :: !isWithinCareCapability(trendSeverity) -> 
      setSeverity(severity, 2)
  :: true
  fi
  setSeverity(trendSeverity, severity)
  logSeverity(severity)
}
\end{lstlisting}
}
%
\noindent Promela semantics are non-deterministic, meaning that the model produces different outcomes from run to run. The model defines where that non-determinism takes place with choices to consider. Model checking considers all the ways possible to resolve the non-determinism to construct an exhaustive proof that a property holds in the model. 

The if-statement is one way to specify a point of non-determinism. In the model for \texttt{severity}, at the top level if-statement, the lone \texttt{:: true}, is an always enabled choice for the if-statement that leaves \texttt{severity} unchanged. The other choices are determined by the \texttt{trendSeverity} value with there being two choices when \texttt{trendSeverity} is within the care capability of the patient.

The final note is that the model synchronizes the value of \texttt{trendSeverity} after choosing a value for \texttt{severity}. The reasoning is that \texttt{severity} should only be updated at the time of an actual exam. As such, \texttt{trendSeverity} should reflect the outcome of since the two values are strongly correlated.

Of note is that \texttt{severity} may never be zero! It is possible for the model checker to resolve the non-determinism in such a way that \texttt{severity} is always one, simply always stays the same, etc. The result is that the patient may never be discharged and may never ever expire at the same time. Such behavior exists in the model but is not consistent with the real world. These are part of the over-approximation, and when necessary, are constrained out by changing the model or constraining what behaviors are considered in the model with a fairness property as discussed previously.

The model for \texttt{trendSeverity} is simple with only two non-deterministic choices that are independent of the actual \texttt{severity} of the patient. 
%
{\small
\begin{lstlisting}[style=myPromela]
inline updateSeverityTrend(trendSeverity) {
  if
  :: true -> 
    setWithinCareCapability(trendSeverity)
  :: true -> 
    setOutsideCareCapability(trendSeverity)
  fi

  logTrend(trendSeverity)
}
\end{lstlisting}
}
%
\noindent The amount that a patient is within or without the bounds of their care capability is not considered in this model; rather, \texttt{trendSeverity} is reduced to a Boolean proposition indicating if the case is one way or the other.

There is one final model that is part of of the environment and that is the model for patient mortality. 
%
{\small
\begin{lstlisting}[style=myPromela]
inline updatePatientMortality(trendSeverity, 
  severity) {
  if
  :: !isWithinCareCapability(trendSeverity) -> 
    setSeverity(severity, EXPIRED)
  :: !isWithinCareCapability(severity) ->
    setSeverity(severity, EXPIRED)
  :: true
  fi
  logSeverity(severity)
}
\end{lstlisting}
}
%
\noindent A patient may expire anytime the \texttt{severity} or \texttt{trendSeverity} is outside the bounds of the care capability.

\subsection{Workflow Environment Model}

The workflow makes decisions at different points based on the values of \texttt{alert}, \texttt{examType}, and \texttt{examTime}. Their values are updated by their associated tasks in the workflow, but how the values evolve over time is not specified. As such, they are modeled as inputs provided by the environment which are sampled when their associated tasks are activated.

The \texttt{alert} is only correlated with \texttt{trendSeverity} in that it is updated whenever the trend is updated, but aside from that, it is unconstrained; thus, it is able to be raised or not raised each time regardless of the value of \texttt{trendSeverity}. The \texttt{examType} is correlated with \texttt{trendSeverity} in that it can become urgent if the trend is outside the care capability level. The \texttt{examTime} is non-deterministic once it is scheduled meaning it randomly choses between leaving it scheduled and having the exam be now.

This non-determinism in \texttt{examTime} means that one behavior in the workflow model is that \texttt{examTime} is never \texttt{now} and is infinitely just \texttt{scheduled}. Such behavior is one of several behaviors that are part of the workflow model but not consistent with the real world in which the workflow exists.
